{
  "paper_id": "2407.05678v4",
  "title": "Computational Power Of Mobile Robots: Discrete Version",
  "published": "2024-07-08T07:25:26Z",
  "authors": [
    "Avisek Sharma",
    "Pritam Goswami",
    "Buddhadeb Sau"
  ],
  "keywords": [
    "Distributed computing",
    "Oblivious robots",
    "Finite-state",
    "Finite-communication",
    "Robots with lights",
    "Model comparison",
    "Discrete domain"
  ],
  "sections": [
    {
      "section_name": "Abstract",
      "text": "In distributed computing by mobile robots, robots are deployed over a region, continuous or discrete, operating through a sequence of look-compute-move cycles. An extensive study has been carried out to understand the computational powers of different robot models. The models vary on the ability to 1) remember constant size information and 2) communicate constant size message. Depending on the abilities the different models are 1) OBLOT (robots are oblivious and silent), 2) FST A (robots have finite states but silent), 3) FCOM (robots are oblivious but can communicate constant size information) and, 4) LUMI (robots have finite states and can communicate constant size information). Another factor that affects computational ability is the scheduler that decides the activation time of the robots. The main three schedulers are fully-synchronous, semi-synchronous and asynchronous. Combining the models (M ) with schedulers (K), we have twelve combinations M K . In the euclidean domain, the comparisons between these twelve variants have been done in different works for transparent robots, opaque robots, and robots with limited visibility. There is a vacant space for similar works when robots are operating on discrete regions like networks. It demands separate research attention because there have been a series of works where robots operate on different networks, and there is a fundamental difference when robots are operating on a continuous domain versus a discrete domain in terms of robots' movement. This work contributes to filling the space by giving a full comparison table for all models with two synchronous schedulers: fully-synchronous and semi-synchronous.",
      "page_start": 1,
      "page_end": 2
    },
    {
      "section_name": "Introduction",
      "text": "In distributed computing swarm robotics is a well-studied area. The last two decades have been dedicated to studying different problems like gathering, pattern formation, exploration, and dispersion etc. The majority of problems have arXiv:2407.05678v4 [cs.DC] 24 Jul 2024 been dealt with in both, first in continuous domains, then in discrete domains. Continuous domains are Euclidean planes, continuous cycles, etc. and discrete domains are different types of finite and infinite graphs. In these problems robots are point computing units deployed over some domain, continuous or discrete. The robots are generally autonomous (the robots do not have central control), identical (indistinguishable from physical appearance), anonymous (the robots do not have any unique identifier) and homogeneous (all robots have same capabilities and runs the same algorithm). The robots operate in look-compute-move (LCM) cycles. On activation, a robots enter in look phase where it finds out the positions of the other robots in its vicinity. Then it enters into compute phase where it runs the inbuilt algorithm to find out where to move or stay put. Next, in move phase the robot moves or stays put according to the decisions in compute phase. In continuous domains, the robots have the freedom to move at any distance with any precision. On the other hand, in discrete domain or in networks the robots are only allowed to move to an adjacent node of its current position. A robot cannot stop in between an edge connecting two nodes. Problem have been considered in discrete domains because sometimes in the practical field the infinite precision in movement by robots is not possible. Also, sometimes the domains are engraved with a predefined networks, like star graphs, line graphs, rectangular and triangular grids, etc.\n\nThe robot models vary on robot capabilities. The two fundamental capabilities are memory and communication. There are main four models: 1) OBLOT , 2) FST A, 3) FCOM and 4) LUMI. The OBLOT model (formally introduced in  [16] ) is the weakest one. In this model, the robots are oblivious, i.e., they do not have persistent memory to remember past actions or past configurations. Also, in this model robots are silent, i.e., they do not have any communication ability. In the LUMI model the robots are equipped with persistent lights that can take finitely many colors. This model is formally introduced in  [5] . At the end of the compute phase, a robot changes the color of the lights as determined by the algorithm. Each robot can see its own color in a look phase. Thus, it serves as a finite memory. Next, other robots can see its lights. Thus, it serves as a communication architecture through which it can communicate a finite bit of information to other robots. The LUMI model is the strongest in terms of memory and communication. The other two intermediate models are introduced in  [10] . We have the first intermediate model FST A. In the FST A model lights of a robot are internal, i.e., it is only visible to itself. Thus, the robots only have finite persistent memory, but the robots are deprived of communication ability. The next intermediate model is FCOM. In this model, the lights of a robot are external, i.e., it cannot see color of its light. Thus, it only gives the ability to communicate a finite number of bits but has no persistent memory.\n\nNext, another key aspect for solving a problem is the considered scheduler. The scheduler is considered an entity that decides when to activate a robot. There are two main types of scheduler. In synchronous scheduler, the time is divided into equal rounds. In each round, a set of robots are activated and they simultaneously perform their LCM cycle. In the fully-synchronous sched-uler (Fsync), in each round, all the robots are activated by the scheduler. On the other hand, in semi-synchronous scheduler (Ssync), introduced in  [16] , a subset of all robots are activated in a particular round. A fair scheduler activates each robot infinitely often. Here we assume that the scheduler is fair. In an asynchronous (Async)scheduler, introduced in  [8] , the robots operate independently of each other and they have no synchrony at all. Also, the length of an LCM cycle of a robot can be unbounded and be different in different activations. A variant M K is a model M together with a scheduler K. For convenience we shall denote M Fsync , M Ssync , and M Async respectively by M F , M S , and M A .\n\nLet X and Y be two variants. Then X > Y denotes that the X is strictly powerful variants than Y, X ≡ Y denotes that the X is computationally equivalent to Y, and X ⊥ Y denotes that X and Y are computationally equivalent. The works in  [2, 3, 5, 9, 11, 13]  refine the computational landscape when transparent robots are operating on the euclidean plane. Then in  [7] , the authors refine the computational landscape when the opaque (non-transparent) robots are operating on the euclidean plane. In the above works, the robots have full visibility. In a similar work in  [4] , the authors considered limited visibility and in this work also, the robots operate on euclidean plane. Similar works are required when the robots are operating on different types of networks. A vast research work has been dedicated to investigating problems like gathering, pattern formation, etc. on different networks. For example, in  [14]  the rendezvous problem (gathering of two robots) has been dealt with in an arbitrary network, in  [1]  the gathering problem has been considered in discrete ring or cycle graph, in  [15]  the arbitrary pattern formation problem has been considered in an infinite rectangular grid. From the above-mentioned model, comparison works for continuous versions, we observe that almost every problem considered for comparison cannot be converted to get a similar result for discrete versions. So a fresh set of problems and a completely different research focus are required for the discrete version.\n\nIn the opinion of the authors, comparison in the discrete domain is slightly more difficult than the comparison in the continuous domain. The reason is as follows. In the continuous domain, the robots can be directed to move at any distance and in any direction. But through finite memory or finite communication, it is not possible to remember or communicate a real number. This limitation has been exploited in the previous works. But in a discrete domain, moving distance is bounded by one hop, and possible directions is also finitely many, as a robot can move to any one of the finitely many adjacent nodes. So, the same method of exploitation does not work in discrete domains. So some completely different problems in nature need to be considered.\n\nTo the best of our knowledge,  [6]  is the only work where authors refine the landscape when the robots are operating on graphs. In  [6] , authors did not consider the models FST A and FCOM. In this work, we give the full computational landscape for all variants M K , where M ∈ {OBLOT , FST A, FCOM, LUMI} and K ∈ {Fsync, Ssync}. And, also refines the computational landscape for the Async scheduler. In the Table  1 , the full comparison is given. In our work the robots are disoriented, i.e., it does not have an agreed notion of clockwise sense or any direction or handedness. The robots have full unobstructed visibility. The proofs of the Lemmas are omitted from the main paper and given in the Appendix Section 8.   2  Model and Preliminaries",
      "page_start": 1,
      "page_end": 1
    },
    {
      "section_name": "Robots",
      "text": "A set R G = {r 1 , r 2 , . . . , r n } of n mobile computing units, called robots operating on a graph G (can be finite or infinite) embedded on the euclidean plane. The robots are anonymous, i.e., the robots do not have any unique identifier; identical, i.e., the robots are indistinguishable from physical appearance; autonomous, i.e., the robots have no central control; homogeneous, i.e., the robots have same capabilities and run the same algorithm. A robot can rest on the nodes of the graphs, and from a node, a robot moves to another adjacent node. A robot cannot stop on an edge connecting to nodes. The robots are equipped with a local coordinate system where the robot considers itself at its origin and can find the position of other robots.",
      "page_start": 1,
      "page_end": 1
    },
    {
      "section_name": "Look-Compute-Move Cycle",
      "text": "The robots operate through a sequence of lookcompute-move (LCM) cycles. On activation, the robots enter into look phase. In this phase, the robot takes an instantaneous snapshot of the surroundings. Thus, it finds out position and states (as declared) of other robots with respect to its local coordinate system. After that, the robot enters into compute phase. In this phase, the robot runs an inbuilt algorithm that takes the information from the snapshot as input. Then it results in a destination position. The destination position is either an adjacent node of the node, or the node itself where the robot is currently situated at. In move phase, the robot moves towards the computed destination position or, makes a null movement and stays put.\n\nAfter the execution of an LCM cycle, a robot becomes inactive. Initially, all robots are inactive. An adversarial scheduler is assumed to be responsible for activating robots. The look phase is considered instantaneous and it is considered as the time instant of the snapshot. The processing and gathering of information from the snapshot is considered in the compute phase. The compute phase ends when the robot starts moving and enters into the move phase. The move phase includes the mechanical movement of the robot.",
      "page_start": 1,
      "page_end": 1
    },
    {
      "section_name": "Considered Robot Models",
      "text": "The weakest and classical robot model is OBLOT . In this model, the robots are not further equipped with any technology that acts as a persistent memory or commutation architecture. Thus, in this model the robots are oblivious (absence of persistent memory) and silent (absence of communication ability). Hence, it cannot remember its past actions or past configurations from the previous LCM cycle.\n\nAnother standard model in the literature is LUMI. In this model, each robot r is equipped with a register Light[r] called light. It can take values from a finite set C. Elements of the sets are called colors. The color of the light of a robot is visible to other robots. A color can be set to the light at the end of the compute phase in an LCM cycle. The color of the light remains persistent in the next cycle and it does not get reset automatically at the end of a cycle. In the LUMI model the snapshot also consists of colors. Thus for each robot, it gets a pair (position, color ). A robot can have more than one light. For these cases, if the robot has k lights, the color can be considered as an k tuple (r.light 1 , . . . , r.light k ) where r.light i is a color from C. Thus, it is equivalent to the case having one light with color set C k (cartesian product of k number of C). Note that, in the LUMI model the set C must have at least two colors. If C has only one color then it is technically an OBLOT model.\n\nThere are two intermediate models of in between the above two which are FST A and FCOM. In the first model, the light is internal. This means that the color of the light is only visible to the robot itself but not to other robots. Each color can be considered a different state of the robots. These robots are silent but they are finite-state. For the second model the the lights are external. This means the colors of the light are visible to other robots but not to itself. This is used to communicate its color with other robots but it cannot see its own color in the next LCM cycle. Thus, the robots are oblivious but enabled with finite communication.\n\nHere, a graph G is considered as an embedded graph, embedded on an Euclidean plane. Suppose a set of more than one robot is placed on G. Let f be a function from the set of vertices of G to N ∪ {0}, where f (v) is the number of robots on the vertex v of G. Then the pair (G, f ) is said to be a configuration of robots on G.\n\nSchedulers Depending on the activation schedule and time duration of LCM cycles of the robots there are main two types of schedulers. First, in a synchronous scheduler, the time is divided equally into rounds. In each round, activated robots simultaneously execute all the phases of the LCM cycles. In a fully-synchronous, (Fsync) scheduler in each round all the robots present in the system get activated. In a semi-asynchronous scheduler (Ssync), a nonempty subset of robots is activated in the scheduler and all activated robots simultaneously execute all the phases of the LCM cycles. A fair scheduler activates each robot infinitely often. We consider all schedulers to be fair. Next, in an asynchronous scheduler (Async) there is no common notion of time for robots. Each robot independently gets activated and executes its LCM cycle. The time length of LCM cycles, compute phases, and move phases of robots may be different. Even the length of two LCM cycles for one robot may be different. The gap between two consecutive LCM cycles, or the time length of an LCM cycle for a robot, is finite but can be unpredictably long. We consider the activation time and the time taken to complete an LCM cycle to be determined by the adversary.",
      "page_start": 1,
      "page_end": 1
    },
    {
      "section_name": "Problems And Computational Relationships",
      "text": "Let M = {OBLOT , FST A, FCOM, LUMI} be the set of models considered in this work, and S = {Fsync, Ssync, Async} be the set of all considered schedulers. A variant M K denotes a model M together with scheduler K. For convenience we shall denote M Fsync , M Ssync , and M Async respectively by M F , M S , and M A .\n\nA problem (or, task) is described by a finite or infinite enumerable sequence of configurations together with some restrictions on the robots. The problem description implicitly gives a set of valid initial configurations. An algorithm A is said to solve a problem P in a variant M K if starting from any valid initial configuration, any execution of A by a set of robots R in the model M under scheduler K can form the configurations given in the sequence in the prescribed order maintaining the restrictions mentioned in P .\n\nLet M ∈ M be a model and K ∈ S, then M (K) is the set of the problems that can be solved in model M under then scheduler\n\n-We say that a variant\n\nOne can easy observe the following result.\n\nLemma 1. For any M ∈ M and K ∈ S, (1)",
      "page_start": 6,
      "page_end": 6
    },
    {
      "section_name": "Comparisons In Fsync",
      "text": "This section compares the models OBLOT , FST A, FCOM and LUMI in a fully-synchronous scheduler.\n\nEquivalency of FCOM F and LUMI F : First, we show the equivalency of the models FCOM and LUMI in a fully synchronous scheduler. For that, we recall the similar result in  [12]  that deals with the same when the robots are operating in the euclidean plane. The proof given in  [12]  is independent of the fact that whether the robots are operating on a euclidean plane or a discrete domain. Hence we can conclude the following result.\n\nNext, let us define a problem named moveOnce below for further developments in this section. Definition 1. Let two robots r i (i = 1, 2) be placed on a vertex v i (i = 1, 2) of a five cycle with a chord such that v 1 and v 2 are not adjacent, and degree of each v i is 2 (Fig.  2 ). The problem moveOnce asks (1) the robot, that has an adjacent node with degree 2, to move once to that adjacent node and stay still afterward, (2) other robot will remain still forever.\n\nTheorem 2. OBLOT F < M F for all M ∈ {FST A, FCOM, LUMI}.\n\nProof. lemma 2 and Lemma 3 show that there exists a problem (moveOnce) that is solvable in FST A F , thus solvable in LUMI F , but not solvable in OBLOT F . The problem moveOnce is solvable in FCOM F from Theorem 1. Hence the result follows.\n\nNext, introduce a new problem by modifying the problem ¬IL defined in  [12]  for the discrete version. Definition 2. Let three robots be placed on a geometric graph given in Fig.  3 . The initial configuration formed by robots is Config-I (Fig.  4 ). In problem ¬IL the robots are required to move to form Config-II (Fig.  5 ). from Config-I, then Config-III (Fig.  6 ) from Config-II. The following Lemma 4 and Lemma 5 follow from the same arguments as given in  [12] . Let us recall the arguments briefly in the next two lines. In the FST A model it is impossible for r 2 to understand which robot has moved to form Config-II. But in FCOM model the moving robot can set a distinct color in order to let r 2 know it.\n\nProof. Lemma 4 and Lemma 5 show that the ¬IL problem is solvable in FCOM F but not solvable in FST A F . Next, from Theorem 1 we have FCOM F and LUMI F are equivalent. Thus, the result is proven.",
      "page_start": 7,
      "page_end": 8
    },
    {
      "section_name": "Comparisons In Ssync",
      "text": "This section compares the models OBLOT , FST A, FCOM, and LUMI in a semi-synchronous scheduler.\n\nTheorem 4. OBLOT S < M S , for all M ∈ {FST A, FCOM, LUMI}.\n\nProof. In Lemma 2 and Lemma 3, we showed that there exists a problem solvable in FST A S , thus also in LUMI S , but not solvable in OBLOT S . Also, in Lemma 4 and Lemma 5, we showed that there exists a problem solvable in FCOM S but solvable in OBLOT S . Hence the result follows.\n\nIn Lemma 2, we have shown that moveOnce is unsolvable in OBLOT F . In the following Lemma 6, we show that moveOnce is unsolvable in FCOM S . Lemma 6. ∃R ∈ R 2 , moveOnce ̸ ∈ FCOM S (R).\n\nTheorem 5. M S < LUMI S for all M ∈ {FST A, FCOM}.\n\nProof. In Lemma 4 and Lemma 5 we showed that there exists a problem that is solvable in LUMI S but not solvable in FST A S . Then, in Lemma 3 and Lemma 6 we showed that there exists a problem that is solvable in LUMI S but not solvable in FCOM S . Hence the result follows.\n\nOrthogonality of FST A S and FCOM S We define a new problem named OSP in the following definition. Definition 3. Suppose, three robots are placed at distinct positions on an infinite discrete line having Configuration A (Fig.  7 ). The OSP problem asks the robots to move such that it creates the following sequence of configurations: <B, C, B, A, B, C, B, A, ... >, where configuration B and C are given in Fig.  8  and Fig.  9  respectively. We show that this problem cannot be solved under semi-synchronous scheduler. Next, we present an algorithm AlgoOSP that solves the OSP in FCOM S . Suppose each robot has an external light that is initially set off color and can take the color colN, colF, and colT. The middle robot does nothing and its color remains off. We denote the color variable of a robot r as color.r.\n\nAlgorithm 1: AlgoOSP: for a generic robot r where r ′ is the other terminal robot; d and d ′ are respectively the distance of r and r ′ from middle robot Proof. In Lemma 3 and Lemma 6, we showed that there exists a problem that is solvable in FST A S but not solvable in FCOM S . In Lemma 7 and Lemma 8 we showed that there exists a problem that is solvable in FCOM S but not solvable in FST A S . Thus the result follows.",
      "page_start": 9,
      "page_end": 10
    },
    {
      "section_name": "Cross-Comparison In Fsync And Ssync",
      "text": "First, we define a modified version of the Stand Up Indulgent Rendezvous (SUIR) problem in the following. Definition 4. Let two robots be placed on the endpoints of a line graph of three nodes (Fig.  10 ). One of the robots may crash (i.e., stop working completely) at any time, and it does not activate ever after. The problem SUIR asks the robots to meet at the middle node (node with degree two) unless one of the robots crashes before gathering. Otherwise, the non-crashed robot moves to the crashed robot's position. A robot cannot identify whether a robot has crashed or not from the snapshot.\n\nProof. In Lemma 9 and Lemma 10 we showed that the problem SUIR is solvable in M F for all M ∈ {OBLOT , FST A, FCOM, LUMI} but not solvable in M S for all M ∈ {OBLOT , FST A, FCOM, LUMI}. Thus, the result follows.\n\nTheorem 8. OBLOT F ⊥ M S for all M ∈ {FST A, FCOM, LUMI}.\n\nProof. In Lemma 9 and Lemma 10, we showed that the problem SUIR is solvable in OBLOT F but not solvable in M S for all M ∈ {FST A, FCOM, LUMI}. In Lemma 2 and Lemma 3 we showed that there exists a problem that solves a problem in FST A S and thus in LUMI S but not solvable in OBLOT F . In Lemma 4 and Lemma 5, we showed that there exists a problem that is solvable in FCOM S but not solvable in OBLOT F . Thus, the result follows.\n\nTheorem 9. OBLOT S < M F for all M ∈ {FST A, FCOM, LUMI}.\n\nProof. From Theorem 4 this result follows.\n\nTheorem 10. M S < LUMI F for all M ∈ {FST A, FCOM}.\n\nProof. FST A S < LUMI F follows from Theorem 3 and FCOM S < LUMI F follows from Theorem 7.\n\nTheorem 11. FST A F ⊥ M S for all M ∈ {FCOM, LUMI}.\n\nTheorem 20. OBLOT A < M A for all M ∈ {FST A, FCOM}.\n\nProof. In Lemma 4 and Lemma 5 we showed that there exists a problem that is solvable in FCOM A but not solvable in OBLOT A . Then, in Lemma 3 and Lemma 6 we showed that there exists a problem that is solvable in FST A A but not solvable in OBLOT A . Hence the result follows.\n\nTheorem 21. OBLOT F ⊥ M A for all M ∈ {FST A, FCOM, LUMI}.\n\nProof. In Lemma 9 and Lemma 10, we showed that the problem SUIR is solvable in OBLOT F but not solvable in M A for all M ∈ {FST A, FCOM, LUMI}. In Lemma 2 and Lemma 3, we showed that there exists a problem that solves a problem in FST A A and thus in LUMI A but not solvable in OBLOT F . In Lemma 4 and Lemma 5, we showed that there exists a problem that is solvable in FCOM A but not solvable in OBLOT F . Thus, the result follows.\n\nTheorem 22. FST A F ⊥ M A for all M ∈ {FCOM, LUMI}.\n\nProof. In Lemma 4 and Lemma 5, we showed that there is a problem that is solvable in FCOM A , thus in LUMI A , but not solvable in FST A F . In Lemma 9 and Lemma 10, we showed that there is a problem that is solvable in FST A F but not solvable in LUMI A , thus not in FCOM A . Thus, the result follows.\n\nTheorem 23. FST A K1 ⊥ FCOM K2 for all K 1 , K 2 ∈ {Async, Ssync}.\n\nProof. If both K 1 and K 2 are Ssync, then it is Theorem 6. In Lemma 3 and Lemma 6, we showed that there exists a problem that is solvable in FST A A but not solvable in FCOM S . In Lemma 7 and Lemma 8 we showed that there exists a problem that is solvable in FCOM A but not solvable in FST A S . Thus, the rest of the result follows.\n\nFinally, we achieve the table in the Figure  1 . In the next section, we conclude the work.",
      "page_start": 11,
      "page_end": 12
    },
    {
      "section_name": "Conclusion",
      "text": "In this work, a complete computational relationships between four different models OBLOT , FST A, FCOM, and LUMI under two synchronous schedulers Fsync and Ssync when a set of anonymous, identical autonomous, homogeneous robots are operating on a graph embedded on euclidean plane. Also, this work refines computational landscape for Async scheduler. A series of works has been dedicated to refine the computational landscape when robots are operating on an euclidean plane, but the same was missing when robots are operating on discrete regions like on different graphs. This work aims to fill the gap. The table in Figure  1  provides the results obtains in this work. Some of the comparisons in Async scheduler are still remain open.",
      "page_start": 13,
      "page_end": 13
    },
    {
      "section_name": "Appendix",
      "text": "Proof of Lemma 2: If possible let there exist an algorithm A that solves the problem in OBLOT F . Since the robots are oblivious and have no communication ability, so after finishing one move of robot r, the configuration remains the same as the initial one. Thus, on activation, the robot r will again move back to its initial position, which is a contradiction.\n\nProof of Lemma 3: Let the robots have two states: off and done. Suppose initially both robots have state off. From the graph topology, the robots can identify which one to move. Let r 1 be the robot that is supposed to move. Then r 2 does not move at all. Then on activation first time (when its state is set as off) r 1 shall move changing its state to done. Next time, on activation it sees its state is set as done, so it does nothing. Even after the move of r 1 is done, the robot r 2 can identify itself as the robot that is not supposed to move. Thus, the above-described algorithm successfully solves moveOnce.\n\nProof of Lemma 6: Let R = {r 1 , r 2 }. If possible let there exist an algorithm A that solves the problem in FCOM S . Let r 2 be the robot that needs to move. Let both robots be activated at every round. Let at k th round r 1 first time moves. Consider another execution where from first to (k -1) th round, both robots get activated, but in k th , r 1 gets activated but r 2 is not. Since the robots have no shared notion of handedness or charity, the view of r 1 remains the same at the start of the (k + 1) th round. Thus, in this execution, r 1 will again move to its initial position, which contradicts the correctness of the A.\n\nProof of Lemma 7: If possible there is an algorithm A that solves the problem in a semi-synchronous scheduler. Consider an execution E where all the robots are activated in each round. Then there will be rounds k 1 , k 2 , k 3 , and k 4 such that (k 1 < k 2 < k 3 < k 4 ) and the following holds true.\n\n-At the end of the k th 1 round the formed configuration is B from initial configuration A and remains till start of the k th 2 round. -At the end of the k th 2 round the formed configuration is C and remains till start of the k th 3 round. -At the end of the k th 3 round the formed configuration is B and remains till start of the k th 4 round. -At the end of the k th 4 round the formed configuration is A. Let r 1 be the terminal robot in the initial configuration that is farther from the middle robot and the r 2 be the other terminal robot. Let consider another execution E 1 where from (k 1 + 1) th round to (k 3 -1) th round the robot r 1 remains inactivated. Then k th 3 round the view and state of r 1 for execution E is the same as the view and state of r 1 in k th 1 round for execution E 1 . As according to execution E of, in E 1 the r 1 will not decide to move if r 1 is activated in k th 3 round. Also from the execution of E, r 2 also does not decide to move on activation in k th 3 round. Thus, after k th 3 round onwards the configuration shall remain the same which is a contradiction. Suppose the other way round happens. If r 2 moves at all without r 1 moving then it will create a configuration that yields a contradiction. Suppose r 1 moves after m rounds of k th 3 round. Then if from k th 1 round if r 2 is not activated for consecutive m rounds then it creates a contradictory configuration. Thus, A cannot solve the problem. Thus the result follows.\n\nProof of Lemma 8: Following lines 1-6 of the Algorithm AlgoOSP the configuration transforms from A to B. Following from lines 7-10 of the Algorithm AlgoOSP the configuration transforms from B to C. Following lines 11-15 of the Algorithm AlgoOSP the configuration transforms from C to B. Following from lines 16-18 of the Algorithm AlgoOSP the configuration transforms from B to A. Then following lines 5-6 the configuration becomes equal to the initial configuration that is, the configuration is A with both robots color off. Thus, we can conclude the result.\n\nProof of Lemma 9: If possible let there exist an algorithm A that solves the problem in LUMI S . The scheduler can activate robots in such a way that it eventually ends up with a configuration where two robots are in one hop. If in each round only one robot is activated alternatively then eventually one of the robots will move toward the other robot, otherwise, the initial configuration will remain forever. Thus eventually a configuration will be formed where two robots are one hop away from each other before gathering. After achieving such a configuration the gathering can be done only if one of the robots moves toward the other but the other does not. Suppose the colors of the robots are such that according to the algorithm say, r 1 is about to move. Then scheduler can choose to crash r 1 . A similar argument can be made for the other robot. Thus, even if one robot does not move in a particular round, it has to choose to move eventually towards the other robot.\n\nLet us end up with a configuration having robot r 1 with color c 1 and having robot r 2 with color c 2 . If for such a scenario both robots are supposed to move through then the scheduler will activate both robots resulting in the same configuration at the end. Suppose for this configuration r 1 would move but r 2 cannot wait forever at that position because r 1 can get crashed at its position. If r 1 does not get activated for enough rounds then r 2 must move towards r 1 after finite rounds. Let the scheduler not activate r 1 for that many rounds then r 2 rounds. Then after that, r 2 after that would move towards r 1 . In that round, if r 1 also chooses to move then the scheduler may choose to activate both robots which results same configuration getting formed again. If r 1 does not move at this round, then also r 1 cannot await there forever using the same argument as we used earlier. Thus in this way, the scheduler can activate the robots in such a way that the robots will not ever gather.\n\nProof of Lemma 10: We design an algorithm in which, on activation, a robot shall move towards the other robot. In the first round, if no robot crashes, then at the end of the round, the gathering will be done. Otherwise, at the end of",
      "page_start": 16,
      "page_end": 17
    }
  ],
  "figures": [
    {
      "caption": "Figure 1: Comparison Table",
      "page": 4
    },
    {
      "caption": "Figure 2: ). The problem moveOnce asks (1) the robot, that has an",
      "page": 7
    },
    {
      "caption": "Figure 2: An image related to problem moveOnce",
      "page": 7
    },
    {
      "caption": "Figure 3: The initial configuration formed by robots is Config-I (Fig. 4). In problem ¬IL",
      "page": 8
    },
    {
      "caption": "Figure 5: ). from Config-I, then",
      "page": 8
    },
    {
      "caption": "Figure 6: ) from Config-II.",
      "page": 8
    },
    {
      "caption": "Figure 3: An image related to problem ¬IL",
      "page": 8
    },
    {
      "caption": "Figure 4: . Config-I",
      "page": 8
    },
    {
      "caption": "Figure 5: Config-II",
      "page": 8
    },
    {
      "caption": "Figure 6: Config-III",
      "page": 8
    },
    {
      "caption": "Figure 7: ). The OSP problem asks the",
      "page": 9
    },
    {
      "caption": "Figure 9: respectively.",
      "page": 9
    },
    {
      "caption": "Figure 7: Configuration A",
      "page": 9
    },
    {
      "caption": "Figure 8: Configuration B",
      "page": 9
    },
    {
      "caption": "Figure 9: Configuration C",
      "page": 10
    },
    {
      "caption": "Figure 10: ). One of the robots may crash (i.e., stop working completely) at",
      "page": 11
    },
    {
      "caption": "Figure 10: An image regarding problem SIUR",
      "page": 11
    },
    {
      "caption": "Figure 1: In the next section, we conclude",
      "page": 13
    },
    {
      "caption": "Figure 1: provides the results obtains in this work. Some of the comparisons",
      "page": 13
    }
  ],
  "tables": [
    {
      "caption": "Table: No caption found",
      "data": [
        {
          "Column_1": "Fig.3. An image related to problem ¬IL\nFig.4. Config-I Fig.5. Config-II Fig.6. Config-III\nThe following Lemma 4 and Lemma 5 follow from the same arguments as\ngiven in [12]. Let us recall the arguments briefly in the next two lines. In the\nFSTA model it is impossible for r to understand which robot has moved to\n2\nform Config-II. But in FCOM model the moving robot can set a distinct color\nin order to let r know it.\n2\nLemma 4. ∃R∈R , ¬IL̸∈FSTAF(R).\n3\nLemma 5. ∀R∈R , ¬IL∈FCOMA(R).\n3",
          "Column_2": "",
          "discrete version.\nition 2. Let three robots be placed on a geometric graph given in Fig. 3.\nitial configuration formed by robots is Config-I (Fig. 4). In problem ¬IL\nots are required to move to form Config-II (Fig. 5). from Config-I, then\n-III (Fig. 6) from Config-II.": "",
          "Column_4": "",
          "Column_5": "",
          "Column_6": "",
          "Column_7": "",
          "Column_8": ""
        },
        {
          "Column_1": "",
          "Column_2": "Fig\nFig.4. Config-I\nThe following Lemm\ngiven in [12]. Let us re\nFSTA model it is imp\nform Config-II. But in\nin order to let r know\n2\nLemma 4. ∃R∈R ,\n3\nLemma 5. ∀R∈R ,\n3",
          "discrete version.\nition 2. Let three robots be placed on a geometric graph given in Fig. 3.\nitial configuration formed by robots is Config-I (Fig. 4). In problem ¬IL\nots are required to move to form Config-II (Fig. 5). from Config-I, then\n-III (Fig. 6) from Config-II.": "Fig\nig.4. Config-I",
          "Column_4": ".3. An image related to problem ¬IL\nFig.5. Config-II Fig.6. Config-III",
          "Column_5": "",
          "Column_6": "",
          "Column_7": "",
          "Column_8": ""
        },
        {
          "Column_1": "",
          "Column_2": "",
          "discrete version.\nition 2. Let three robots be placed on a geometric graph given in Fig. 3.\nitial configuration formed by robots is Config-I (Fig. 4). In problem ¬IL\nots are required to move to form Config-II (Fig. 5). from Config-I, then\n-III (Fig. 6) from Config-II.": "",
          "Column_4": "a 4 and Lemma 5 follow from the same arguments as\ncall the arguments briefly in the next two lines. In the\nossible for r to understand which robot has moved to\n2\nFCOM model the moving robot can set a distinct color\nit.\n¬IL̸∈FSTAF(R).\n¬IL∈FCOMA(R).",
          "Column_5": "",
          "Column_6": "",
          "Column_7": "",
          "Column_8": ""
        }
      ],
      "page": 8
    },
    {
      "caption": "Table: No caption found",
      "data": [
        {
          "finition 3. Suppose, three robots are placed at distinct positions on an infi-\ndiscrete line having Configuration A (Fig. 7). The OSP problem asks the\nots to move such that it creates the following sequence of configurations: <B,\nB, A, B, C, B, A, ... >, where configuration B and C are given in Fig. 8 and\n. 9 respectively.": "Fig.7. Configuration A\nFig.8. Configuration B\nWe show that this problem cannot be solved under semi-synchronous sched-\nr."
        }
      ],
      "page": 9
    }
  ],
  "citations": [
    {
      "citation_id": "1",
      "title": "Stand-up indulgent gathering on rings",
      "authors": [
        "Q Bramas",
        "S Kamei",
        "A Lamani",
        "S Tixeuil"
      ],
      "year": "2024",
      "venue": "Structural Information and Communication Complexity -31st International Colloquium, SIROCCO 2024",
      "doi": "10.1007/978-3-031-60603-8_7"
    },
    {
      "citation_id": "2",
      "title": "Autonomous mobile robots: Refining the computational landscape",
      "authors": [
        "K Buchin",
        "P Flocchini",
        "I Kostitsyna",
        "T Peters",
        "N Santoro",
        "K Wada"
      ],
      "year": "2021",
      "venue": "IEEE International Parallel and Distributed Processing Symposium Workshops, IPDPS Workshops 2021",
      "doi": "10.1109/IPDPSW52791.2021.00091"
    },
    {
      "citation_id": "3",
      "title": "On the computational power of energy-constrained mobile robots: Algorithms and cross-model analysis",
      "authors": [
        "K Buchin",
        "P Flocchini",
        "I Kostitsyna",
        "T Peters",
        "N Santoro",
        "K Wada"
      ],
      "year": "2022",
      "venue": "Structural Information and Communication Complexity -29th International Colloquium, SIROCCO 2022, Paderborn",
      "doi": "10.1007/978-3-031-09993-9_3"
    },
    {
      "citation_id": "4",
      "title": "The computational landscape of autonomous mobile robots: The visibility perspective",
      "authors": [
        "A Das",
        "S Ghosh",
        "A Sharma",
        "P Goswami",
        "B Sau"
      ],
      "year": "2024",
      "venue": "Distributed Computing and Intelligent Technology -20th International Conference",
      "doi": "10.1007/978-3-031-50583-6_6"
    },
    {
      "citation_id": "5",
      "title": "Autonomous mobile robots with lights",
      "authors": [
        "S Das",
        "P Flocchini",
        "G Prencipe",
        "N Santoro",
        "M Yamashita"
      ],
      "year": "2016",
      "venue": "Theor. Comput. Sci",
      "doi": "10.1016/J.TCS.2015.09.018"
    },
    {
      "citation_id": "6",
      "title": "Characterizing the computational power of mobile robots on graphs and implications for the euclidean plane",
      "authors": [
        "M D'emidio",
        "G Stefano",
        "D Frigioni",
        "A Navarra"
      ],
      "year": "2018",
      "venue": "Inf. Comput",
      "doi": "10.1016/J.IC.2018.09.010"
    },
    {
      "citation_id": "7",
      "title": "3rd Symposium on Algorithmic Foundations of Dynamic Networks (SAND 2024)",
      "authors": [
        "C Feletti",
        "L Mambretti",
        "C Mereghetti",
        "B Palano"
      ],
      "year": "2024",
      "venue": "Leibniz International Proceedings in Informatics (LIPIcs)",
      "doi": "10.4230/LIPIcs.SAND.2024.13"
    },
    {
      "citation_id": "8",
      "title": "Hard tasks for weak robots: The role of common knowledge in pattern formation by autonomous mobile robots",
      "authors": [
        "P Flocchini",
        "G Prencipe",
        "N Santoro",
        "P Widmayer"
      ],
      "year": "1999",
      "venue": "Proceedings of the 10th International Symposium on Algorithms and Computation"
    },
    {
      "citation_id": "9",
      "title": "On asynchrony, memory, and communication: Separations and landscapes",
      "authors": [
        "P Flocchini",
        "N Santoro",
        "Y Sudo",
        "K Wada"
      ],
      "year": "2023",
      "venue": "27th International Conference on Principles of Distributed Systems, OPODIS 2023",
      "doi": "10.4230/LIPICS.OPODIS.2023.28"
    },
    {
      "citation_id": "10",
      "title": "Rendezvous with constant memory",
      "authors": [
        "P Flocchini",
        "N Santoro",
        "G Viglietta",
        "M Yamashita"
      ],
      "year": "2016",
      "venue": "Theor. Comput. Sci",
      "doi": "10.1016/J.TCS.2016.01.025"
    },
    {
      "citation_id": "11",
      "title": "On memory, communication, and synchronous schedulers when moving and computing",
      "authors": [
        "P Flocchini",
        "N Santoro",
        "K Wada"
      ],
      "year": "2019",
      "venue": "23rd International Conference on Principles of Distributed Systems",
      "doi": "10.4230/LIPICS.OPODIS.2019.25"
    },
    {
      "citation_id": "12",
      "title": "On Memory, Communication, and Synchronous Schedulers When Moving and Computing",
      "authors": [
        "P Flocchini",
        "N Santoro",
        "K Wada"
      ],
      "year": "2019",
      "venue": "23rd International Conference on Principles of Distributed Systems",
      "doi": "10.4230/LIPIcs.OPODIS.2019.25"
    },
    {
      "citation_id": "13",
      "title": "Separating bounded and unbounded asynchrony for autonomous robots: Point convergence with limited visibility",
      "authors": [
        "D Kirkpatrick",
        "I Kostitsyna",
        "A Navarra",
        "G Prencipe",
        "N Santoro"
      ],
      "year": "2021",
      "venue": "PODC '21: ACM Symposium on Principles of Distributed Computing, Virtual Event",
      "doi": "10.1145/3465084.3467910"
    },
    {
      "citation_id": "14",
      "title": "Deterministic treasure hunt and rendezvous in arbitrary connected graphs",
      "authors": [
        "D Pattanayak",
        "A Pelc"
      ],
      "year": "2024",
      "venue": "Inf. Process. Lett",
      "doi": "10.1016/J.IPL.2023.106455"
    },
    {
      "citation_id": "15",
      "title": "Space and move-optimal arbitrary pattern formation on a rectangular grid by robot swarms",
      "authors": [
        "A Sharma",
        "S Ghosh",
        "P Goswami",
        "B Sau"
      ],
      "year": "2024",
      "venue": "Proceedings of the 25th International Conference on Distributed Computing and Networking, ICDCN 2024",
      "doi": "10.1145/3631461.3631542"
    },
    {
      "citation_id": "16",
      "title": "Distributed anonymous mobile robots",
      "authors": [
        "I Suzuki",
        "M Yamashita"
      ],
      "year": "1996",
      "venue": "SIROCCO'96, The 3rd International Colloquium on Structural Information & Communication Complexity"
    }
  ]
}